"""Research agent with budget management."""

import time
from typing import Dict, List
from .budgets import BudgetManager, RunBudget
from .token_utils import estimate_tokens


class ResearchAgent:
    """A research agent that searches documents and synthesizes answers with budget control."""
    
    def __init__(self, budget: RunBudget):
        self.budget = budget
    
    def search_documents(self, query: str, max_results: int = 5) -> List[str]:
        """
        Simulate document search.
        
        In production, this would call a vector database or search API.
        """
        # Simulate search results
        return [
            f"Document {i+1}: Comprehensive information about {query}. "
            f"This document contains detailed explanations, examples, and use cases related to {query}."
            for i in range(max_results)
        ]
    
    def synthesize_answer(self, query: str, documents: List[str], budget_manager: BudgetManager) -> str:
        """Synthesize answer from documents with budget checks."""
        context = "\n".join(documents)
        prompt = f"Question: {query}\n\nContext:\n{context}\n\nAnswer:"
        
        estimated_tokens = estimate_tokens(prompt) + 500  # Estimate response size
        
        if not budget_manager.can_make_call(estimated_tokens):
            # Budget exhausted - return summary
            return self._graceful_exit(query, documents, budget_manager)
        
        # Simulate model call
        # In production, this would call an actual LLM API
        response = (
            f"Based on the {len(documents)} documents I found, here's what I learned about {query}: "
            f"[This is a synthesized answer combining information from multiple sources. "
            f"In a real implementation, this would be generated by an LLM.]"
        )
        
        tokens_used = estimate_tokens(prompt) + estimate_tokens(response)
        budget_manager.record_call(tokens_used, step_type="synthesis")
        
        return response
    
    def _graceful_exit(self, query: str, documents: List[str], budget_manager: BudgetManager) -> str:
        """Handle budget exhaustion gracefully."""
        remaining = budget_manager.remaining()
        
        # Try to provide a brief summary if we have any tokens left
        if remaining["tokens"] > 100:
            summary_prompt = f"Briefly summarize findings about: {query}"
            summary = (
                f"Summary: Found {len(documents)} relevant documents about {query}. "
                f"Budget limit reached before full synthesis."
            )
            tokens_used = estimate_tokens(summary_prompt) + estimate_tokens(summary)
            budget_manager.record_call(tokens_used, step_type="summary")
            return f"Budget limit reached. {summary}"
        
        return (
            f"Budget limit reached. Found {len(documents)} documents about {query}. "
            f"Please try with a larger budget for full synthesis."
        )
    
    def answer(self, query: str) -> Dict:
        """
        Answer a question with budget management.
        
        Returns:
            Dict with answer, metadata, and budget usage information.
        """
        budget_manager = BudgetManager(self.budget)
        
        # Step 1: Search documents
        estimated_search_tokens = estimate_tokens(query) + 1000
        if not budget_manager.can_make_call(estimated_search_tokens):
            return {
                "answer": "Budget exhausted before search.",
                "documents_found": 0,
                "budget_used": {
                    "steps": budget_manager.steps_used,
                    "tokens": budget_manager.tokens_used,
                    "seconds": time.time() - budget_manager.start_time
                },
                "budget_remaining": budget_manager.remaining(),
                "budget_exhausted": True
            }
        
        documents = self.search_documents(query)
        budget_manager.record_call(estimated_search_tokens, is_tool_call=True, step_type="search")
        
        # Step 2: Synthesize answer
        answer = self.synthesize_answer(query, documents, budget_manager)
        
        return {
            "answer": answer,
            "documents_found": len(documents),
            "budget_used": {
                "steps": budget_manager.steps_used,
                "tokens": budget_manager.tokens_used,
                "seconds": time.time() - budget_manager.start_time
            },
            "budget_remaining": budget_manager.remaining(),
            "budget_exhausted": budget_manager.is_exhausted()
        }

